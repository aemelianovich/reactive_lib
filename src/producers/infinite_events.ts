/* eslint-disable @typescript-eslint/no-explicit-any */
import { EventEmitter } from 'node:events';
import type { InfiniteIterable } from './infinite_iterable.js';

type ETarget = EventTarget | EventEmitter;

class InfiniteEvent {
  target: ETarget;
  event: string;
  payload: Event | any[] | null;
  // Сделать перегрузку конструктора
  constructor(target: ETarget, event: string, payload: Event | any[] | null) {
    this.target = target;
    this.event = event;
    this.payload = payload ?? null;
  }
}

/**
 * Creates special async iterable based on passed EventTarget or EventEmitter and Event type
 * Each time when new event will be occured the new special InfiniteEvent value will be generated by async iterator
 *
 */
class InfiniteEvents<T extends InfiniteEvent>
  implements InfiniteIterable<T>, AsyncIterable<T>
{
  resolvers: ((value: IteratorResult<T, any>) => void)[];
  target: ETarget;
  event: string;
  constructor(target: ETarget, event: string) {
    this.target = target;
    this.event = event;
    this.resolvers = [];

    // Переделать через Map, т.к. легче будет менять код
    if (target instanceof EventTarget) {
      target.addEventListener(event, (e) => {
        const res = new InfiniteEvent(this.target, this.event, e);
        this.resolve(<T>(<any>res));
      });
    } else if (target instanceof EventEmitter) {
      target.on(event, (...args) => {
        const res = new InfiniteEvent(this.target, this.event, args);
        this.resolve(<T>(<any>res));
      });
    } else {
      throw new Error(`Passed target is not supported:${typeof target}`);
    }
  }

  resolve(value: T): void {
    if (this.resolvers != null) {
      for (const resolve of this.resolvers) {
        resolve({ done: false, value });
      }
      this.resolvers.splice(0, this.resolvers.length);
    }
  }

  [Symbol.asyncIterator](): AsyncIterableIterator<T> {
    const setResolve = (cb: (value: IteratorResult<T>) => void) => {
      this.resolvers.push(cb);
    };

    return {
      [Symbol.asyncIterator]() {
        return this;
      },
      next() {
        return new Promise((resolve) => {
          setResolve(resolve);
        });
      },
    };
  }
}

export default InfiniteEvents;
